/*
  SGPacMan - Salvat Game Pacman (https://sourceforge.net/projects/sgfpacman/)
  Copyright (C) 2010-2011 Salvatore Giannotta Filho <a_materasu@hotmail.com>

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

  */
#ifdef printf
#undef printf
#endif

#include "Game.h"
#include "Settings.h"
#include "PacGlobal.h"

class CConfiguration;
#define BACKGROUND 0


extern Debug::CLog logtxt;
extern CPacConfiguration settings;

bool Game::showfps=false;

void Game::editorSave() {
    int i=-1, j=-1;

    if ( settings.baddiestartx == -1 ||
         settings.baddiestarty == -1 ||
         settings.pacstartx == -1 ||
         settings.pacstarty == -1 ) {
        std::cerr << "Specify pacman and ghost start locations before saving\n";
        return;
    }

    //save

    std::ofstream file;
    bool error=0;		//1 on error


    if (editorpath == "") editorpath = "./levels/new/";
    file.open( (editorpath + MAPFILE).c_str()/*, std::ios::out */);

    if (!file) error=true;

    if (!error) {
        file << "/ Pacman Revolutions mapfile generated by Pacman level editor"	<< std::endl;
        for (j=0;j<settings.fieldheight; j++) {
            for (i=0;i<settings.fieldwidth; i++) {
               // file << map[j*settings.fieldwidth+i] << "  ";
				fieldMap.setTyleType(j,i,atoi(" "));
				file << fieldMap.getTyleType(i,j);
            }
            file << std::endl;
        }
    }

    if (file.is_open() ) file.close();


    file.open( (editorpath + OBJFILE).c_str() );
    if (!file) error=1;

    if (!error) {
        file << "/ Pacman Revolutions objectmap generated by Pacman level editor"	<< std::endl;
        for (j=0;j<settings.fieldheight; j++) {
            for (i=0;i<settings.fieldwidth; i++) {
                //file << objmap[j*settings.fieldwidth+i] << "  ";
				objMap.setTyleType(j,i,atoi(" "));
				file << objMap.getTyleType(i,j);
			}
            file << std::endl;
        }
    }

    if (file.is_open() ) file.close();

    file.open ( ( editorpath + CFGFILE ).c_str());
    if (!file) error=true;

    if (!error) {
        file << "/ Pacman Revolutions config file generated by Pacman level editor =;"	<< std::endl;
        file << "FIELDWIDTH=" << settings.fieldwidth << ";" << std::endl;
        file << "FIELDHEIGHT=" << settings.fieldheight << ";" << std::endl;
        file << "TILESIZE=" << settings.tilesize << ";" << std::endl;
        file << "PACSPEED=" << settings.pacspeed << ";" << std::endl;
        file << "BADDIESPEED=" << settings.baddiespeed << ";" << std::endl;
        file << "BADDIEIQ=" << settings.baddieiq << ";" << std::endl;
        file << "VULN_DURATION=" << settings.vuln_duration << ";" << std::endl;
        file << "PACSTARTX=" << settings.pacstartx  << ";" << std::endl;
        file << "PACSTARTY=" << settings.pacstarty << ";" << std::endl;
        file << "BADDIESTARTX=" << settings.baddiestartx << ";" << std::endl;
        file << "BADDIESTARTY=" << settings.baddiestarty << ";" << std::endl;
    }
    if ( file.is_open() ) file.close();

    bool isincluded = false;
    for (i=0;i< settings.lvlpathcount;i++) {
        if ( editorpath == settings.lvlpath[i] ) isincluded = true;
    }
    if ( !isincluded && !error) {
        file.open("pacman.cfg", std::ios::out | std::ios::app);
        if (!file) error=true;
        else {
            file << "\nLEVEL_PATH=" << editorpath;
            if (file.is_open()) file.close();
            settings.lvlpath.push_back(editorpath);
            settings.lvlpathcount++;
        }
    }


    if (error) {
        std::cerr << "Save failed";
    }
}

void Game::logicEditor() {

    if ( inputwaiting) {
        if ( key == Left ) {

            if ( activetool <= 0 ) activetool = 15;
            else activetool--;
        }
        else if ( key == Right ) {

            if ( activetool >= 15 ) activetool = 0;
            else activetool++;
        }
        else if ( key == Click ) {
			if (activetool < 10)
				fieldMap.setTyleType(mouseX / settings.tilesize,mouseY / settings.tilesize,activetool);

            else if (activetool == 14) {
                settings.pacstartx = mouseX / settings.tilesize;
                settings.pacstarty = mouseY / settings.tilesize;
            }
            else if (activetool == 15 ) {
                settings.baddiestartx = mouseX / settings.tilesize;
                settings.baddiestarty = mouseY / settings.tilesize;
            }
            else
				objMap.setTyleType((mouseX-10) / settings.tilesize,(mouseY - 10) / settings.tilesize,activetool-10);

        }
    }

}

void Game::renderEditor() {
    //Todo
}

void Game::initEditor() {
	
	fieldMap.reset();
	objMap.reset();
    //create new empty maps
    if ( editorpath == "" ) {
        fieldMap.resize(settings.fieldheight , settings.fieldwidth);
		fieldMap.setTileSize(settings.tilesize);
		objMap.resize(settings.fieldheight , settings.fieldwidth);
		objMap.setTileSize(settings.tilesize);

        settings.baddiestartx = -1;
        settings.baddiestarty = -1;
        settings.pacstartx = -1;
        settings.pacstarty = -1;
        settings.gatex = -1;
        settings.gatey = -1;
    }
    //load existing map
    else {

        //load settings

		settings.loadConfigurations( editorpath + CFGFILE );

        //if level has different field size than currently selected, setup new window with proper size
		if (settings.fieldwidth*settings.tilesize != gameControl->getScreen()->getWidth()
			|| settings.fieldheight*settings.tilesize+EXTRA_Y_SPACE != gameControl->getScreen()->getHeight()) {
           // app.InitWindow();
            logtxt.print("window resized...");
        }

        //load maps

        fieldMap.resize(settings.fieldheight , settings.fieldwidth);
		objMap.resize(settings.fieldheight , settings.fieldwidth);
		fieldMap.loadCharMap( editorpath + MAPFILE);
		objMap.loadCharMap( editorpath + MAPFILE);
                //if loading is successful, set editorpath

    }

}
void Game::changeSkin() {
    int i;

	for (i=0;i<NUMOFOBJECTS;i++) {
		(objects[i])->setObjectPath(settings.skinspath[settings.skinspathcurrent]);
		objects[i]->load();
	}
}

void Game::run(Game & thisGame){
	Debug::debug(Debug::gameEngine,__FUNCTION__) << " BEGIN RUN THE GAME==========================" << endl;

    struct GameState{
        GameState():
            endMatch(false){
            }

        bool endMatch;
    };

    class Logic: public Input::CLogic {
    public:
        Logic(GameState & state, Game * thisGame):
        state(state),
        pacGame(thisGame),
		xpos(0),
		ypos(0)
		{


            /* FIXME: use an enum here */
			gameInput.set(CKeyboard::Key_UP, 10, false, Up);
			gameInput.set(CKeyboard::Key_DOWN, 10, false, Down);
            gameInput.set(CKeyboard::Key_LEFT, 10, false, Left);
            gameInput.set(CKeyboard::Key_RIGHT, 10, true, Right);
			gameInput.set(CKeyboard::Key_ENTER, 0, true, Select);
			gameInput.set(CKeyboard::Key_ESC, 0, true, 6);
			gameInput.set(CKeyboard::Key_SPACE, 0, true, 7);
			gameInput.set(CKeyboard::Key_P, 0, true, 8);
			gameInput.set(CKeyboard::Key_S, 10, true, 9);
			gameInput.set(CKeyboard::Key_E, 0, true, 10);
			gameInput.set(CKeyboard::Key_W, 0, true, 11);
			gameInput.set(CKeyboard::Key_F, 0, true, 12);
			gameInput.set(CKeyboard::Key_N, 0, true, 13);
			gameInput.set(CKeyboard::Key_L, 0, true, 14);
			gameInput.set(CKeyboard::Key_Q, 0, true, 15);
			gameInput.set(CKeyboard::Key_H, 0, true, 17);
			gameInput.set(CKeyboard::Key_T, 0, true, 18);
			//gameInput.set(CMouse::Key_MoveLEFT, 0, true, Left);
			//gameInput.set(CMouse::key_MoveRIGHT, 0, true, Right);
			gameInput.set(CMouse::Key_LEFT, 0, true, Click);
			//gameInput.set(CMouse::Key_MoveUP,0,true,Up);
			//gameInput.set(CMouse::Key_MoveDOWN,0,true,Down);
            //gameInput.set(CConfiguration::config(0).getJoystickQuit(), 0, true, 4);
            gameInput.set(CKeyboard::Key_F5, 10, true, 5);
        }
		//! Keys
        CInputMap<int> gameInput;
        GameState & state;
        Game *pacGame;
        int xpos;
		int ypos;



     void doInput(){

 	 Debug::debug(Debug::gameEngine,__FUNCTION__) << "BEGIN FASE 1 - Get Events "<<  endl;
	 vector<CInputMap<int>::InputEvent> events = CInputManager::getEvents(gameInput);
	 Debug::debug(Debug::gameEngine,__FUNCTION__) << "END FASE 1 - Got Events: "<< events.size()<<  endl;
	 Debug::debug(Debug::gameEngine,__FUNCTION__) << "BEGIN FASE 2 - Proccess Events "<<  endl;

    for (vector<CInputMap<int>::InputEvent>::iterator it = events.begin(); it != events.end(); it++){
        const CInputMap<int>::InputEvent & event = *it;

		if (!event.enabled){
            continue;
        }

        if (event.out == Cancel){
                 pacGame->doAction(Cancel) ;
        }

       	Debug::debug(Debug::gameEngine,__FUNCTION__) << "Will Begin Doing Actions:  "<< event.out <<  endl;

        switch (event.out){
                case Up: pacGame->doAction(Up); break;
                case Down: pacGame->doAction(Down); break;
                case Left: pacGame->doAction(Left); break;
                case Right: pacGame->doAction(Right); break;
				case Select: pacGame->doAction(Select); break;
				case 6: pacGame->doAction(Cancel); break;
				case 7: pacGame->doAction(Modify); break;
				case 8: pacGame->doAction(Pause); break;
				case 9: pacGame->doAction(ChangeSkin); break;
				case 10: pacGame->doAction(InitEditor); break;
				case 11: pacGame->doAction(SaveEditor); break;
				case 12: pacGame->doAction(ShowFPS); break;
				case 13: pacGame->doAction(ActionN); break;
				case 14: pacGame->doAction(ChangeLevel); break;
				case 15: pacGame->doAction(ActionH); break;
                case 16: {
						pacGame->doAction(Click,event.mouseXpos,event.mouseYpos);
						Debug::debug(Debug::gameEngine,__FUNCTION__) << "Click Detected [x,y] "<< event.mouseXpos << " , "<< event.mouseYpos<<  endl;
						break;
						 }
                case 17: pacGame->doAction(Help); break;
				case 18: pacGame->doAction(TogleSound); break;
                default: break;
            }

		}

		}

        virtual void run(){
            // Do stage logic catch match exception to handle the next match
			Debug::debug(Debug::gameEngine,__FUNCTION__) << " WILL RUN THE STAGE LOGIC=========================" << endl;

			pacGame->processLogic();
            //state.endMatch = stage->isMatchOver();

			Debug::debug(Debug::gameEngine,__FUNCTION__) << " BEGIN DO THE INPUT=========================" << endl;

            doInput();
			Debug::debug(Debug::gameEngine,__FUNCTION__) << " END DO THE INPUT=========================" << endl;

        }

        virtual bool done(){
			return pacGame->getGameControl()->getQuit();
        }

        virtual double ticks(double system){
            return Util::gameTicks(system, 0.1); //0.1 = gamespeed
        }
    };

    class Draw: public Input::CDraw {
    public:
        Draw(Game * stage):
            pacGame(stage),
				work(CConfiguration::getScreenWidth(),CConfiguration::getScreenHeight()){
            }

        Game * pacGame;
        CBitmap work;

        virtual void draw(double fps){

			Debug::debug(Debug::gameEngine,__FUNCTION__) << " WILL RENDER EVERYTHING to Work: [(CBitmao:: "<< &work<<" ) (Surface: "<< work.getBitmap()<<" )]=========================" << endl;

			//work.clear();
			pacGame->act();

            Debug::debug(Debug::gameEngine,__FUNCTION__) << " EVERYTHING IS RENDERED =========================" << endl;

			if (showfps){
				CResource::getDefaultFont()->DrawTextNew(0,pacGame->gameControl->getScreen()->getHeight()-80,Colors::White, work,"%2.2f FPS",fps);

				Debug::debug(Debug::gameEngine,__FUNCTION__) << " FRAME y =========================" <<pacGame->gameControl->getScreen()->getHeight()-100<< endl;
           }
			work.updateTexture();
			work.BlitToScreen();

        }
    };

    GameState state;
    Logic logic(state,&thisGame); // this não pode ser usado aqui por ser um método estático
    Draw draw(&thisGame);
	Debug::debug(Debug::gameEngine,__FUNCTION__) << " BEGIN DRAW =========================" << endl;
	//Executa aqui o loop do Jogo
	Input::SGE_standardLoop(logic, draw);
	Debug::debug(Debug::gameEngine,__FUNCTION__) << " END DRAW =========================" << endl;

	Debug::debug(Debug::gameEngine,__FUNCTION__) << " END RUN THE MATCH==========================" << endl;

}


void Game::doAction(Actions Action, int mousex, int mousey) {

	Debug::debug(Debug::gameEngine,__FUNCTION__) << "WILL EXECUTE ACTION:  "<< Action <<  endl;


        switch(Action) {


            case Cancel:
                gameControl->setQuit(true);
                break;
            case Up:
                processInput(Up);
                break;
            case Down:
                processInput(Down);
                break;
            case Left:
                processInput(Left);
				break;
            case Right:
                processInput(Right);
                break;
            case Modify:
                boost();
                break;
            case Pause:
                if ( getState() == STATE_GAME )
                    pause();
                break;
            case ActionN:
                if ( getState() != STATE_ENTER_HSCORE )
                    gameInit();
                break;
            case ChangeLevel:
                settings.lvlpathcurrent++;
                if ( settings.lvlpathcurrent >= settings.lvlpathcount)
                    settings.lvlpathcurrent=0;
                gameInit();
                break;
            case ChangeSkin:
                settings.skinspathcurrent++;
                if ( settings.skinspathcurrent >= settings.skinspathcount)
                    settings.skinspathcurrent=0;
                changeSkin();
                break;
            case InitEditor:
                initEditor();
                setState( STATE_EDITOR );
                break;
            case SaveEditor:
                //                        std::cerr << "w: save map not yet implemented";
                editorSave();
                break;
            case ShowFPS:
                toggleFps();
                break;
            case ActionH:
                setState( STATE_VIEW_HSCORE );
                break;
            case Select:
                processInput(Select);
                break;
            case Help:
                if ( getState() == STATE_GAME )
                    help();
                break;
			case Click:

				 if ( getState() == STATE_EDITOR )
					processInput( Click, mousex, mousey);
            break;
			case TogleSound:
				
			break;
            default:
                break;
            }


}




void Game::clearHscore() {
    //Todo
}

void Game::renderViewHscore() {
	//Todo
}

void Game::setState(int st) {
    int i;

    if ( st == STATE_GAME ) {
		
        for (i=0;i<NUMOFOBJECTS;i++) if (objects[i]) (objects[i])->setAlpha(255);
        for (i=0;i<NUMOFOBJECTS;i++) if ( objects[i] ) (objects[i])->setPaused( false);

    }
    else if ( st == STATE_ENTER_HSCORE ) {

       
        for (i=0;i<NUMOFOBJECTS;i++) if ( objects[i] ) (objects[i])->setPaused( true);
        for (i=0;i<NUMOFOBJECTS;i++) if (objects[i]) (objects[i])->setAlpha(150);

    }
    else if ( st == STATE_VIEW_HSCORE ) {

        for (i=0;i<NUMOFOBJECTS;i++) if (objects[i]) (objects[i])->setAlpha(150);
        for (i=0;i<NUMOFOBJECTS;i++) if ( objects[i] ) (objects[i])->setPaused( true);
    }
    else if ( st == STATE_STOPPED && state != STATE_STOPPED) {
		for (i=0;i<NUMOFOBJECTS;i++) if ( objects[i] ) (objects[i])->setPaused( true);
        for (i=0;i<NUMOFOBJECTS;i++) if (objects[i]) (objects[i])->setAlpha(255);
    }
    else if ( st == STATE_EDITOR ) {
		for (i=0;i<NUMOFOBJECTS;i++) if (objects[i]) (objects[i])->setAlpha(255);

        activetool = 1;
    }

    state = st;

}

void Game::logicEnterHscore() {
    int j;

    if ( inputwaiting ) {

        switch ( key ) {
        case Right :
            if (hscoreselection==2) hscoreselection=0;
            else hscoreselection++;
            for (j=0;j<3;j++) namecol[j]= 150;
            namecol[ hscoreselection ] = 255;
            break;
        case Left :
            if (hscoreselection==0) hscoreselection=2;
            else hscoreselection--;
            for (j=0;j<3;j++) namecol[j]= 150;
            namecol[ hscoreselection ] = 255;
            break;
        case Down :
            if (name[hscoreselection]=='A') name[hscoreselection]='_';
            else if (name[hscoreselection]=='_') name[hscoreselection]='Z';
            else name[hscoreselection]--;
            break;
        case Up :
            if (name[hscoreselection]=='Z') name[hscoreselection]='_';
            else if (name[hscoreselection]=='_') name[hscoreselection]='A';
            else name[hscoreselection]++;
            break;
        case Select :
            setState( STATE_VIEW_HSCORE) ;
        default :
             break;
        }
    }
}
void Game::logicGame() {
    int
            i, j,
            delta,
            pacX,
            pacY,
            pacXpix,
            pacYpix,
            ghostXpix[4],
            ghostYpix[4],
            oldscore(score);

    delta = (int)(time -oldtime);

    if ( gamestarted && !ispaused ) {
		Debug::debug(Debug::gameEngine,__FUNCTION__) << " WILL START GAME LOGIC" << endl;
		Debug::debug(Debug::gameEngine,__FUNCTION__) << "(1) - GET POSITONS" << endl;
        //////////////////////////////////
        //	GET POSITIONS
        //////////////////////////////////

        //////////////////////////////////
        // MOVE LOGIC
        //////////////////////////////////

        if ( delta < 100 )  {
            //set ghost targets - 2 on pacman, 2 on next intersection
			Debug::debug(Debug::gameEngine,__FUNCTION__) << "(2) - MOVE OBJCTS" << endl;

            {
                int tmpx(  pacXpix / settings.tilesize),
                tmpy(  pacYpix / settings.tilesize);

            }

            //move objects

            for (i=0;i<NUMOFOBJECTS;i++){
				 //Quake( delta );
                (objects[i])->act(NULL,NULL,NULL); // delta );
			}
        }
        ///////////////////////////////////////////
        //	TIME LOGIC
        ///////////////////////////////////////////

        //if ghost timer is up, set ghosts to normal mode

        if ( vulnflag && time > ghosttick ) {
            for (i=0;i<4;i++) {
            }
            vulnflag= false;
            deadghostcount= 0;

        }

        // if less than 2 secs left in vuln mode, set warning mode

        else if ( vulnflag && time > ghosttick -2000) for (i=0;i<4;i++) {
            }

        // fruit stuff

        if ( specialspawned && !specialeaten && (fruittick - time < 2000) ) {
            ((BckgrObj*)objects[BACKGROUND])->setFruitAlpha( 55 + (fruittick - time) / 10 );
        }
        if ( time > fruittick && specialspawned && !specialeaten) {
            specialspawned = false;
            ((BckgrObj*)objects[BACKGROUND])->setSpecialSpawned(false);
        }

        ///////////////////////////////////////////
        // PACMAN LOCATION LOGIC
        ///////////////////////////////////////////
		Debug::debug(Debug::gameEngine,__FUNCTION__) << "(3) - VERIFY COLISION WITH OTHER OBJECTS" << endl;
        
        ///////////////////////////////////
        //	OTHER
        ///////////////////////////////////

        if ( (score >= 10000 && oldscore < 10000) ||
             (score >=100000 && oldscore < 100000) ||
             (score >=1000000 && oldscore < 1000000) ) {
            lives++;

        }

        if ( !specialhasbeenspawned && ((BckgrObj*)objects[BACKGROUND])->getObjCount() == specialspawntime) {
            specialspawned = true;
            ((BckgrObj*)objects[BACKGROUND])->setFruitAlpha(255);
            ((BckgrObj*)objects[BACKGROUND])->setSpecialSpawned(true);
            fruittick = SDL_GetTicks() + FRUITDURATION;
        }

        if ( ((BckgrObj*)objects[BACKGROUND])->getObjCount() == 0 ) {
            levelcleared = true;
            act();
            nextLvl();
        }
        //		else (gameControl->getSnd()->modify( 10, 44100 - ((BckgrObj*)objects[BACKGROUND])->getObjCount() * 75) );
    }
}
void Game::renderEnterHscore() {

    // Todo
}
void Game::showEditorHelpScreen() {

						ostringstream out;
						out << "TECLA -> AÇÃO                \n";
						out << "_____________________________\n";
						out << "(H) -> Mostra tela de Help\n";
						out << "(P) -> Pausa o Jogo \n";
						out << "(Q) -> Mostra HSore \n";
						out << "(S) -> Muda Skin\n";
						out << "(E) -> Inicia Editor\n";
						out << "(W) -> Salva Editor \n";
						out << "(F) -> Mostra FPS\n";
						out << "(N) -> Reinicia o Game\n";
						out << "(L) ->  Muda de Level\n";
						out << "(Enter) -> Inicio\n";
						out << "(ESC) -> Sai\n";
						out << "(SPACE) -> Boost \n";


						const CFont *font = (CFont *) CResource::getDefaultFont();
						Util::popup(*font, out.str());
}

void Game::showHelpScreen() {

						ostringstream out;
						out << "TECLA -> AÇÃO                \n";
						out << "_____________________________\n";
						out << "(H) -> Mostra tela de Help\n";
						out << "(P) -> Pausa o Jogo \n";
						out << "(Q) -> Mostra HSore \n";
						out << "(S) -> Muda Skin\n";
						out << "(E) -> Inicia Editor\n";
						out << "(W) -> Salva Editor \n";
						out << "(F) -> Mostra FPS\n";
						out << "(N) -> Reinicia o Game\n";
						out << "(L) ->  Muda de Level\n";
						out << "(Enter) -> Inicio\n";
						out << "(ESC) -> Sai\n";
						out << "(SPACE) -> Boost \n";


						const CFont *font = (CFont *) CResource::getDefaultFont();
						Util::popup(*font, out.str());
}
void Game::draw( CBitmap * work ) {
    int i;
    std::ostringstream ostr;
    Colors::ColorDefinition col;
    col.r = col.g = col.b = 255;

    //s try {
        // DRAW FIELD + SPRITES

        for (i=0;i<NUMOFOBJECTS;i++) if ( objects[i] ) objects[i]->draw();

        // DRAW SCORE + INFO

        
        if ( specialeaten ) ((BckgrObj*)objects[BACKGROUND])->Draw( settings.fieldwidth*settings.tilesize - 40 -10, settings.fieldheight*settings.tilesize +15 );
        if ( boostavailable ) ((BckgrObj*)objects[BACKGROUND])->Draw( settings.fieldwidth*settings.tilesize - 60 -10, settings.fieldheight*settings.tilesize +15, 4 );

		//if (CResource::getDefaultFont()) {
			CTTFFont *tempfont=CResource::getDefaultFont();
			tempfont->printf( scorebox.x,scorebox.y, col, *this->gameControl->getScreen(),"LEVEL: %d   SCORE: %d",level,level,score) ;
			//this->gameControl->getScreen()->Render("TESTE", 100,100,col,tempfont);
//			tempfont->DrawTextNew(scorebox.x,scorebox.y,col,*this->gameControl->getScreen(),"LEVEL: %d   SCORE: %d",level,score);

		//}

        //DRAW SCORE POPUP
        if (floatingscorecounter != 0) {
            std::ostringstream scoretext;

            scoretext << floatingscore;
            floatingscorecounter--;

            floatingscorebox.y--;
			//SDL_SetAlpha(txt,SDL_SRCALPHA,	55+floatingscorecounter*2);
			//if (CResource::getDefaultFont())
			CResource::getDefaultFont()->DrawTextNew(floatingscorebox.x,floatingscorebox.y,col,*this->gameControl->getScreen(),"%s",scoretext.str().c_str());

        }

        // PAUSE

        if ( ispaused ) {
            SDL_Rect pauserect;
            pauserect.y = settings.fieldwidth*settings.tilesize / 2 - 100;
            pauserect.w = 200;
            pauserect.x = settings.fieldheight*settings.tilesize / 2 - 10;
            pauserect.h = 50;
			CResource::getDefaultFont()->DrawTextNew(pauserect.x,pauserect.y,col,*this->gameControl->getScreen(),"%s","PAUSED");
            if ( showHelp ) showHelpScreen();
        }

        // LEVEL CLEARED

        else if ( levelcleared ) {
            SDL_Rect pauserect;
            pauserect.x = settings.fieldwidth*settings.tilesize / 2 - 200;
            pauserect.w = 400;
            pauserect.y = settings.fieldheight*settings.tilesize / 2 - 10;
            pauserect.h = 50;
			//if (CResource::getDefaultFont())
			CResource::getDefaultFont()->DrawTextNew(pauserect.x,pauserect.y,col,*this->gameControl->getScreen(),"%s","LEVEL CLEARED!");

        }
 /*  }

    catch ( CGeneralError& err ) {
        std::cerr << err.getFullReason();
        gameControl->setQuit(true);
        logtxt.print( err.getFullReason() );
    }
    catch ( ... ) {
        Debug::debug(Debug::gameEngine,__FUNCTION__) << "Unexpected exception"<< endl;
		gameControl->setQuit(true);

    } */
}

void Game::boost() {

}
void Game::help() {
    int i;

    if ( !ispaused ) {
        ispaused = true;
        for (i=0;i<NUMOFOBJECTS;i++) (objects[i])->setPaused(true);

        pausetick = SDL_GetTicks();
		showHelp = true;

    }
    else {
        ispaused = false;
		showHelp = false;
		for (i=0;i<NUMOFOBJECTS;i++) (objects[i])->setPaused( false);

        int delta( SDL_GetTicks() - pausetick );

        ghosttick += delta;
        fruittick += delta;
        boosttick += delta;


    }
}
void Game::pause() {
    int i;

    if ( !ispaused ) {
        ispaused = true;
        for (i=0;i<NUMOFOBJECTS;i++) (objects[i])->setPaused(true);

        pausetick = SDL_GetTicks();


    }
    else {
        ispaused = false;
		for (i=0;i<NUMOFOBJECTS;i++) (objects[i])->setPaused( false);

        int delta( SDL_GetTicks() - pausetick );

        ghosttick += delta;
        fruittick += delta;
        boosttick += delta;


    }
}
void Game::nextLvl() {
    std::string tmpstr;


    try {
        level++;

        objscore*=2;
        settings.vuln_duration -= settings.vuln_duration/10;

        
        tmpstr = settings.lvlpath[settings.lvlpathcurrent] + OBJFILE;
        if ( ! objMap.loadCharMap(tmpstr) )
            throw CGeneralError("CGeneralError loading objmap.txt during Game::nextLvl()");

        vulnflag= false;
        deadghostcount= 0;
        floatingscorecounter = 0;
        floatingscore = 0;
        specialspawned = false;
        ((BckgrObj*)objects[BACKGROUND])->setSpecialSpawned(false);
        specialeaten = false;
        ((BckgrObj*)objects[BACKGROUND])->setSpecialEaten(false);
        specialhasbeenspawned = false;
        time = oldtime = SDL_GetTicks();
        ghosttick = 0;
        isboosted = false;
        boostavailable = true;
        levelcleared = false;

        if (ispaused) pause();


        SDL_Delay(1000);


        act();
        specialspawntime = rand() % (((BckgrObj*)objects[BACKGROUND])->getObjCount() -20) + 10;

        //emptyMsgPump();
        inputwaiting = false;
        gamestarted = false;
    }
    catch ( CGeneralError &err) {
        std::cerr << err.getFullReason();
        gameControl->setQuit(true);
        logtxt.print( err.getFullReason() );
    }
    catch ( ... ) {
        std::cerr << "Unexpected exception in Game::nextLvl()";
        gameControl->setQuit(true);
        logtxt.print( "Unexpected error in Game::nextLvl()" );
    }
}

void Game::gameInit(std::string level, std::string skin, bool editor) {
    int i;
    std::string tmpstr;

    // try {
        isinit=false;
        //m_Game.getSnd()->stop();

        //try to set level/skins path
        settings.setPath(MODE_LEVELS,level);
        settings.setPath(MODE_SKINS,skin);

        tmpstr = settings.lvlpath[settings.lvlpathcurrent] + CFGFILE;
		settings.loadConfigurations(tmpstr);
       // if ( !settings.loadConfigurations(tmpstr) )
         //   throw CGeneralError("CGeneralError loading level settings");

        //resetting variables
        score=0;
        vulnflag= false;
        deadghostcount= 0;
        ghosttick = 0;
        floatingscorecounter = 0;
        floatingscore = 0;
        lives = 3;
        level = 1;
        objscore = 200;
        specialspawned = false;
        specialeaten = false;
        specialhasbeenspawned = false;
        inputwaiting = false;
        gamestarted = false;
        isboosted = false;
        time = oldtime = SDL_GetTicks();
        boostavailable = true;
        levelcleared = false;
		showHelp = false;
        setState( STATE_GAME);
        name = "AAA";
        namecol[0] = 255;
        namecol[1] = 150;
        namecol[2] = 150;
        hscoreselection = 0;


        if ( ispaused )
            pause();

        scorebox.x= 20;
        scorebox.w = 500;
        scorebox.y = settings.fieldheight * settings.tilesize ;
        scorebox.h = 50;



        //DYNAMIC OBJECTS INIT
		fieldMap.reset();
        objMap.reset();

		Debug::debug(Debug::gameEngine,__FUNCTION__) << " WILL DELETE OBJECTS==========================" << endl;

		if (objects[BACKGROUND]) {delete (BckgrObj *) objects[BACKGROUND];objects[BACKGROUND] = NULL;}

		 for (i=2; i< NUMOFOBJECTS; i++) {

			if (objects[i]) {
				delete objects[i];
                objects[i] = NULL;
            }

          }
		Debug::debug(Debug::gameEngine,__FUNCTION__) << "END DELETING OBJECTS==========================" << endl;
	    Debug::debug(Debug::gameEngine,__FUNCTION__) << "Unloading complete" << endl;

        //if level has different field size than currently selected, setup new window with proper size
		if (settings.fieldwidth*settings.tilesize != CConfiguration::getScreenWidth()
			|| settings.fieldheight*settings.tilesize+EXTRA_Y_SPACE != CConfiguration::getScreenHeight()) {
           // app.InitWindow();
           //Todo Resize Window
				logtxt.print("window resized...");
        }

        // INIT MAPS
		fieldMap.resize(settings.fieldheight,settings.fieldwidth);
		objMap.resize(settings.fieldheight,settings.fieldwidth);

        tmpstr = settings.lvlpath[settings.lvlpathcurrent];

        if ( !fieldMap.loadCharMap(tmpstr + MAPFILE) )
            throw CGeneralError("Failed to load map.txt");
        if ( !objMap.loadCharMap(tmpstr + OBJFILE) )
            throw CGeneralError("Failed to load objmap.txt");

        logtxt.print("Maps loaded");

        //loading level graphics

        objects[BACKGROUND] = new BckgrObj( 10 ,settings.skinspath[settings.skinspathcurrent]);

        logtxt.print("Level background loaded");


		setState( STATE_STOPPED);

        //create pacman + ghosts

        

      
        logtxt.print("Objects loaded");

        //calculate special fruit spawn time

        if (!editor) act();
        specialspawntime = rand() % (((BckgrObj*)objects[BACKGROUND])->getObjCount() -20) + 10;

        //emptyMsgPump();
        inputwaiting = false;
        gamestarted = false;

        isinit = true;

        if (editor) {
            initEditor();
            setState(STATE_EDITOR);
        }
    /*}
    catch ( CGeneralError &err) {
        std::cerr << err.getFullReason();
        gameControl->setQuit(true);
        logtxt.print( err.getFullReason() );
    }
    catch ( ... ) {
        std::cerr << "Unexpected exception in Game::gameInit()";
        gameControl->setQuit(true);
        logtxt.print( "Unexpected error in Game::gameInit()" );
    } */
}


void Game::reloadLevel() {	// vars and positions when pacman dies during level
	
    SDL_Delay(1000);
	//! toca o som 9
   
    // setting vars
    vulnflag= false;
    deadghostcount= 0;
    floatingscorecounter= 0;
    floatingscore= 0;
    ghosttick = 0;
    isboosted = false;
	showHelp = false;
    
    if (ispaused) pause();

    
   act();
    //emptyMsgPump();
    gamestarted= false;
    inputwaiting = false;
}
void Game::processInput(int k, int ix, int iy) {

    inputwaiting = true;

    key = k;
    if ( key == Click ) {
        mouseX = ix;
        mouseY = iy;
    }

    if ( !gamestarted && !ispaused ) {
        gamestarted = true;
        if ( state == STATE_STOPPED || state == STATE_GAME )
            setState( STATE_GAME );
    }
}

void Game::processLogic() {

    time = SDL_GetTicks();

    if ( state == STATE_GAME ) logicGame();
    else if (state == STATE_ENTER_HSCORE ) logicEnterHscore();
    else if (state == STATE_EDITOR ) logicEditor();

    oldtime = time;
    inputwaiting = false;
}

void Game::getMaps( CMap *m, CMap*o) {
    (*m)=fieldMap;
    (*o)=objMap;
}
void Game::act() {
	Debug::debug(Debug::gameEngine,__FUNCTION__) << "BEGIN RENDER GAME"<< endl;

    Colors::ColorDefinition
            col;

    col.r = col.g = col.b = 255;

   /* if (counter == 100) {   // a cada 100 execuções de render ele pega o valor de FPS
        fps = getFPS();
        counter = 0;
    } */

 //   try {
        if ( !renderisbusy ) {
            renderisbusy = true;

            ////////////////////////////////
            // STATE SWITCH
            ////////////////////////////////

            if ( (state == STATE_GAME) || (state == STATE_STOPPED) ) draw();
            else if (state == STATE_ENTER_HSCORE ) renderEnterHscore();
            else if (state == STATE_VIEW_HSCORE ) renderViewHscore();
            else if (state == STATE_EDITOR )renderEditor();


            if ( showfps ) {
				//if (CResource::getDefaultFont())
				CResource::getDefaultFont()->DrawTextNew(fpsbox.x,fpsbox.y,col,*this->gameControl->getScreen(),"%s",fps.c_str());

            }


            renderisbusy = false;
      //      counter++;
        }
  /*  }
    catch ( CGeneralError& err ) {
        //std::cerr << err.getFullReason();
        gameControl->setQuit(true);
         Debug::debug(Debug::gameEngine,__FUNCTION__) << err.getFullReason() << endl;
    }
    catch ( ... ) {
        gameControl->setQuit(true);
        Debug::debug(Debug::gameEngine,__FUNCTION__) << "Unexpected exception in Game::Render"<< endl;

    } */
	Debug::debug(Debug::gameEngine,__FUNCTION__) << "END RENDER GAME"<< endl;
}


void Game::PrepareShutdown() {
    int i;
	for (i=0;i<NUMOFOBJECTS;i++) if ( objects[i] ) delete objects[i];
}
Game::Game()
:   isinit(false),
    state(STATE_STOPPED),
    counter(0),
    deadghostcount(0),
    lives(2),
    objscore(200),
    floatingscore(0),
    floatingscorecounter(0),
    specialspawntime(0),
    level(1),
    hscoreselection(0),
    soundcounter(0),
    inputwaiting(false),
    gamestarted(false),
    showHelp(false),
	vulnflag(false),
    specialspawned(false),
    specialeaten(false),
    specialhasbeenspawned(false),
    ispaused(false),
    isboosted(false),
    renderisbusy(false)

{
    int i;

    time = oldtime = ticks = SDL_GetTicks();

    fps = "loading";

    fpsbox.x= 10;
    fpsbox.w = 290;
    fpsbox.y = 10;
    fpsbox.h = 190;

    for (i=0;i<NUMOFOBJECTS;i++) objects[i]=NULL;

    for (i=0;i<10;i++)
        num[i]='0'+i;

    name = "AAA";
    namecol[0] = 255;
    namecol[1] = 150;
    namecol[2] = 150;
}

Game::~Game()
{


}

//Constructor
CPacGameControl::CPacGameControl():
pCurInputManager(CInputManager::GetInstance()),  //! Deve inicializar o Input Manager
work(NULL),
quit(false)
{

}

//Destructor
CPacGameControl::~CPacGameControl()
{
	 Debug::debug(Debug::gameEngine,__FUNCTION__) << "BEGIN Deleting CPacGameControl" << endl;
	try {
        
		Debug::debug(Debug::gameEngine,__FUNCTION__) << "END Deleting CPacGameControl" << endl;

    }

    catch ( CGeneralError& err ) {
        std::cerr << (err.getFullReason() );
        setQuit(true);
        logtxt.print( err.getFullReason() );
    }
    catch (...) {
        Debug::debug(Debug::gameEngine,__FUNCTION__) << "Unexpected exception";
        setQuit(true);
        //logtxt.print( "Unexpected exception in App::~App()" );
    }
	Debug::debug(Debug::gameEngine,__FUNCTION__) << "END Deleting CPacGameControl" << endl;
}





void  CPacGameControl::initWindow() {
    try {

		if ( work )
            delete work;
		work = new CBitmap(settings.getScreenWidth(), settings.getScreenHeight()+EXTRA_Y_SPACE);
		logtxt.print("WORK CREATED");
		
        if (work == NULL)
            throw CGeneralError("CGeneralError while setting video mode");

        logtxt.print("Work Bitmap CREATED Sucessfully");
    }
    catch ( CGeneralError& err ) {
        std::cerr << (err.getFullReason() );
        //setQuit(true);
        logtxt.print( err.getFullReason() );
    }
    catch (...) {
        std::cerr << "Unexpected exception in: "<< __FUNCTION__;
        //setQuit(true);
        logtxt.print( "Unexpected exception in CPacGameControl::App()" );
    }
}
